<map version="1.0.1"><node CREATED="1620645739936" ID="ID_root" MODIFIED="1620645739936" TEXT="数据结构"><node CREATED="1620645739936" ID="ID_32ab6a28625f" POSITION="right" MODIFIED="1620645739936" TEXT="数据结构的基本概念"><node CREATED="1620645739936" ID="ID_32d6556c672c" MODIFIED="1620645739936" TEXT="数据结构"><node CREATED="1620645739936" ID="ID_1e9caacc8361" MODIFIED="1620645739936" TEXT="逻辑结构"><node CREATED="1620645739936" ID="ID_b1a230433baa" MODIFIED="1620645739936" TEXT="集合"></node><node CREATED="1620645739936" ID="ID_b0a64da91353" MODIFIED="1620645739936" TEXT="线性结构"></node><node CREATED="1620645739936" ID="ID_e99fc74cac52" MODIFIED="1620645739936" TEXT="树形结构"></node><node CREATED="1620645739936" ID="ID_76869f8f51c5" MODIFIED="1620645739936" TEXT="图形结构"></node></node><node CREATED="1620645739936" ID="ID_4e0959e8d52c" MODIFIED="1620645739936" TEXT="存储结构"><node CREATED="1620645739936" ID="ID_d28bd2c93470" MODIFIED="1620645739936" TEXT="顺序存储"></node><node CREATED="1620645739936" ID="ID_0f3cc002d272" MODIFIED="1620645739936" TEXT="链式存储"></node><node CREATED="1620645739936" ID="ID_450bc8651196" MODIFIED="1620645739936" TEXT="索引存储"></node><node CREATED="1620645739936" ID="ID_6dd816b6b86e" MODIFIED="1620645739936" TEXT="散列存储"></node></node><node CREATED="1620645739936" ID="ID_f559359a3714" MODIFIED="1620645739936" TEXT="数据操作"><node CREATED="1620645739936" ID="ID_0ef58df7aec5" MODIFIED="1620645739936" TEXT="创建、增删改查、遍历、销毁"></node></node></node><node CREATED="1620645739936" ID="ID_b9884a06305e" MODIFIED="1620645739936" TEXT="数据抽象"><node CREATED="1620645739936" ID="ID_9c9ba5aae31d" MODIFIED="1620645739936" TEXT="JAVA泛型"><node CREATED="1620645739936" ID="ID_d98686b214f8" MODIFIED="1620645739936" TEXT="抽象类Object：由继承该抽象类的子类表示抽象类型的实现"></node><node CREATED="1620645739936" ID="ID_c2c10c759697" MODIFIED="1620645739936" TEXT="抽象Comparable接口：由实现该接口的类表示抽象类型的实现。"></node></node></node><node CREATED="1620645739936" ID="ID_fbd1b776917c" MODIFIED="1620645739936" TEXT="时间复杂度: 数据元素个数n的多项式的最高次幂的项并去掉其系数"></node><node CREATED="1620645739936" ID="ID_dab4557a6eec" MODIFIED="1620645739936" TEXT="空间复杂度：算法执行占用的存储空间量"></node></node><node CREATED="1620645739936" ID="ID_b0d629516b24" POSITION="right" MODIFIED="1620645739936" TEXT="线性表"><node CREATED="1620645739936" ID="ID_5ba77b6d511e" MODIFIED="1620645739936" TEXT="抽象数据类型"><node CREATED="1620645739936" ID="ID_9210123a191e" MODIFIED="1620645739936" TEXT="Java:&amp;nbsp;IList接口"></node></node><node CREATED="1620645739936" ID="ID_80c19914f1e3" MODIFIED="1620645739936" TEXT="顺序表（顺序存储）"><node CREATED="1620645739936" ID="ID_e9c14b33e8a6" MODIFIED="1620645739936" TEXT="特点：&amp;lt;br&amp;gt;1. 逻辑上相邻的元素在物理存储位置上也相邻&amp;lt;br&amp;gt;2. 可按照元素的位序号进行随机存取&amp;lt;br&amp;gt;3. 进行插入删除操作需要移动大量的数据元素&amp;lt;br&amp;gt;4. 需要进行存储空间的预先分配，可能会造成空间浪费，但存储密度较高。"></node></node><node CREATED="1620645739936" ID="ID_4b97236b2b29" MODIFIED="1620645739936" TEXT="链式表（链式存储）"><node CREATED="1620645739936" ID="ID_3ed33324551d" MODIFIED="1620645739936" TEXT="单链表：只包含一个指针域（指向后继节点的指针）的链表"><node CREATED="1620645739936" ID="ID_cfd8e72c6a6c" MODIFIED="1620645739936" TEXT="特点：&amp;lt;br&amp;gt;1. 存在是否带头结点的考虑（头结点不存放任何数据，指针域存放指向第一个结点的指针）&amp;lt;br&amp;gt;2. 结点的存储空间是在插入和删除过程中动态申请和释放的，不需要预先分配&amp;lt;br&amp;gt;"></node></node><node CREATED="1620645739936" ID="ID_687cba10d3dc" MODIFIED="1620645739936" TEXT="循环链表"><node CREATED="1620645739936" ID="ID_489d85c3a37b" MODIFIED="1620645739936" TEXT="特点：将链表的首尾相接，将尾结点的指针域指向头结点的指针。"></node></node><node CREATED="1620645739936" ID="ID_9d620ef10993" MODIFIED="1620645739936" TEXT="双向链表"><node CREATED="1620645739936" ID="ID_f3a87bbccc8d" MODIFIED="1620645739936" TEXT="特点：具有两个指针域，一个指向前驱结点，一个指向后继结点。使得查找某个结点的前驱结点不需要从表头开始顺着链表依次进行查找，减小时间复杂度。"></node></node><node CREATED="1620645739936" ID="ID_c0484a6b9bf7" MODIFIED="1620645739936" TEXT="顺序表和链表的比较"><node CREATED="1620645739936" ID="ID_ddcfca264c58" MODIFIED="1620645739936" TEXT="顺序表：&amp;lt;br&amp;gt;1. 存储密度高，空间开销小。可用数组实现。&amp;lt;br&amp;gt;2. 需要预先分配存储空间。存取的时间复杂度为 O(1)。&amp;lt;br&amp;gt;3. 不便于动态操作（插入、删除）。插入删除元素的复杂度为 O(n)"></node><node CREATED="1620645739936" ID="ID_d3c8b27aae40" MODIFIED="1620645739936" TEXT="链表：&amp;lt;br&amp;gt;1. 存储密度低&amp;lt;br&amp;gt;2. 存储空间动态分配&amp;lt;br&amp;gt;3. 插入、删除效率高,时间复杂度为&amp;nbsp;O(1)。&amp;lt;br&amp;gt;4. 不可按照位序号随机存取. 必须从头结点开始沿着后继结点进行访问，时间复杂度O(n)。"></node></node></node><node CREATED="1620645739936" ID="ID_e8e4584a9ec4" MODIFIED="1620645739936" TEXT="hashmap"><node CREATED="1620645739936" ID="ID_6571c33694bd" MODIFIED="1620645739936" TEXT="拉链表"></node></node></node><node CREATED="1620645739936" ID="ID_e3399a1e874b" POSITION="right" MODIFIED="1620645739936" TEXT="栈和队列"><node CREATED="1620645739936" ID="ID_cd538b67d1ee" MODIFIED="1620645739936" TEXT="数据类型定义: Java IStack接口"></node><node CREATED="1620645739936" ID="ID_a84ce9de3f61" MODIFIED="1620645739936" TEXT="栈"><node CREATED="1620645739936" ID="ID_795e313dc9e1" MODIFIED="1620645739936" TEXT="特点：&amp;lt;br&amp;gt;先进后出&amp;lt;br&amp;gt;栈顶top"></node><node CREATED="1620645739936" ID="ID_7f24ff5beba6" MODIFIED="1620645739936" TEXT="顺序栈"><node CREATED="1620645739936" ID="ID_f9a67e3c8efd" MODIFIED="1620645739936" TEXT="应用"><node CREATED="1620645739936" ID="ID_abc082e31c02" MODIFIED="1620645739936" TEXT="括号匹配语法检查"></node></node><node CREATED="1620645739936" ID="ID_0d3bddb4d235" MODIFIED="1620645739936" TEXT="多栈空间共享"><node CREATED="1620645739936" ID="ID_fa813a5f9a61" MODIFIED="1620645739936" TEXT="两个栈的栈顶在栈空间的某一位置相遇时，才产生上溢"></node></node></node><node CREATED="1620645739936" ID="ID_7bf33c0f983d" MODIFIED="1620645739936" TEXT="链栈"><node CREATED="1620645739936" ID="ID_1d9de4cf596f" MODIFIED="1620645739936" TEXT="特点：&amp;lt;br&amp;gt;1. 依然是入栈出栈只能在栈顶进行，所以不存在在栈的任意位置进行插入和删除的操作，&amp;lt;br&amp;gt;top指向栈顶元素结点，每个结点的指针域指向后继结点。&amp;lt;br&amp;gt;2. 入栈： 构造新结点，改变新结点和首结点的指针域，使新结点成为新的栈顶结点。&amp;lt;br&amp;gt;出栈：修改top指针域的值，返回被删结点的数据域值。"></node><node CREATED="1620645739937" ID="ID_cf002f451550" MODIFIED="1620645739937" TEXT="应用：汉诺塔问题"></node></node></node><node CREATED="1620645739937" ID="ID_58c0598bf247" MODIFIED="1620645739937" TEXT="队列"><node CREATED="1620645739937" ID="ID_992bea547d79" MODIFIED="1620645739937" TEXT="特点：&amp;lt;br&amp;gt;先进先出&amp;lt;br&amp;gt;front 队首元素，出队，增加变量&amp;lt;br&amp;gt;rear 队尾元素，入队。"></node><node CREATED="1620645739937" ID="ID_713bd18bf52f" MODIFIED="1620645739937" TEXT="顺序队列"><node CREATED="1620645739937" ID="ID_b23b7e88cf20" MODIFIED="1620645739937" TEXT="存在假溢出现象，存储单元没有重复使用机制"></node></node><node CREATED="1620645739937" ID="ID_60629a240dfb" MODIFIED="1620645739937" TEXT="循环顺序队列"><node CREATED="1620645739937" ID="ID_d17060d861c8" MODIFIED="1620645739937" TEXT="队空条件: front == rear"></node><node CREATED="1620645739937" ID="ID_f160c3da83a6" MODIFIED="1620645739937" TEXT="队满条件: front =(rear +1) %maxSize"></node></node><node CREATED="1620645739937" ID="ID_c2ddf76c451e" MODIFIED="1620645739937" TEXT="链队列"><node CREATED="1620645739937" ID="ID_9f077e9b59b2" MODIFIED="1620645739937" TEXT="特点：&amp;lt;br&amp;gt;1.依然不存在在队列的任意位置进行插入和删除的情况，不需要设置头结点，只需要将front和rear分别指向队首结点和队尾结点，每个结点的指针域指向后继结点。"></node><node CREATED="1620645739937" ID="ID_31bc03c7df9b" MODIFIED="1620645739937" TEXT="也存在假溢出现象"></node></node><node CREATED="1620645739937" ID="ID_c8c678890f9d" MODIFIED="1620645739937" TEXT="优先级队列（堆可以当作优先级队列来使用）"><node CREATED="1620645739937" ID="ID_7387d6449ea1" MODIFIED="1620645739937" TEXT="特点：&amp;lt;br&amp;gt;1. 在普通队列的基础之上将队列中的数据元素按照关键字的值进行有序排列。&amp;lt;br&amp;gt;2. 在队首进行删除操作，插入操作不一定在队尾进行，而是按照优先级插入到队列的合适位置。&amp;lt;br&amp;gt;3. 为了快速访问优先级高的元素，以及快速地插入数据元素，通常使用链式存储结构。"></node><node CREATED="1620645739937" ID="ID_f59f93f483cf" MODIFIED="1620645739937" TEXT="应用：&amp;lt;br&amp;gt;进程服务对CPU的获取&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;"></node></node><node CREATED="1620645739937" ID="ID_66655e1a18b2" MODIFIED="1620645739937" TEXT="双端队列"><node CREATED="1620645739937" ID="ID_7f992a1746d8" MODIFIED="1620645739937" TEXT="双端队列是一种插入和删除操作在两端均可进行的线性表，可以把双端队列看成栈底连在一起的两个栈。他们与两个栈共享存储空间的共享栈的不同指出是，两个栈的栈顶指针式向两端延伸的。由于双端队列允许在两端插入和删除元素，因此需要设立两个指针，分别指向双端队列中两端的元素。&amp;lt;br&amp;gt;允许在一端进行插入和删除（进队和出队），另一端只允许删除的双端队列称为输入受限的双端队列&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1620645739937" ID="ID_139d14dc974c" MODIFIED="1620645739937" TEXT="栈和队列的比较"><node CREATED="1620645739937" ID="ID_e8467796d29f" MODIFIED="1620645739937" TEXT="1. 顺序栈可以实现多栈空间共享，而顺序队列不可以"></node></node></node><node CREATED="1620645739937" ID="ID_6846c4174724" POSITION="right" MODIFIED="1620645739937" TEXT="串和数组"><node CREATED="1620645739937" ID="ID_c292c7de9ec7" MODIFIED="1620645739937" TEXT="串（字符串），数据类型定义，Java IString 接口"><node CREATED="1620645739937" ID="ID_609476775042" MODIFIED="1620645739937" TEXT="串和线性表区别：串是一种特殊的线性表，其中元素全部为字符型；串和线性表的操作有较大的区别；串通常以整体作为操作的对象，而线性表通常以单个元素作为操作的对象。"></node><node CREATED="1620645739937" ID="ID_693e1890d98d" MODIFIED="1620645739937" TEXT="顺序串"><node CREATED="1620645739937" ID="ID_2997e6a666bf" MODIFIED="1620645739937" TEXT="字符数组构造串"></node><node CREATED="1620645739937" ID="ID_e6262966ee75" MODIFIED="1620645739937" TEXT="增、删、比较，往往把字符串看成一个整体"></node></node><node CREATED="1620645739937" ID="ID_439acdee94d9" MODIFIED="1620645739937" TEXT="链串"><node CREATED="1620645739937" ID="ID_3a35ab8dcef0" MODIFIED="1620645739937" TEXT="特点：&amp;lt;br&amp;gt;1. 由一系列大小相同的结点组成，每个结点用数据域存放字符&amp;lt;br&amp;gt;2. 若每个结点的数据域为 一个字符 = 单字符链表&amp;lt;br&amp;gt;若每个结点的数据域为 多个字符 = 块链表&amp;lt;br&amp;gt;3. 在串的链式存储中，单字符链表的插入删除操作较为简单，但存储效率低。块链表虽然存储效率高但插入删除操作需要移动字符，较为复杂。"></node></node><node CREATED="1620645739937" ID="ID_07ff580a1f70" MODIFIED="1620645739937" TEXT="模式匹配（在当前串寻找模式串）"><node CREATED="1620645739937" ID="ID_2a7619c3484d" MODIFIED="1620645739937" TEXT="Brute-Force"><node CREATED="1620645739937" ID="ID_fd908ee23fbb" MODIFIED="1620645739937" TEXT="从主串的第一个字符开始和模式串的第一个字符比较，相等则比较后续字符。不相等则从第二个字符开始重新和模式串进行比较"></node><node CREATED="1620645739937" ID="ID_fd5b4c803817" MODIFIED="1620645739937" TEXT="特点：效率低,存在重复比较"></node><node CREATED="1620645739937" ID="ID_58276fa3f2fd" MODIFIED="1620645739937" TEXT="时间复杂度(m为模式串的长度，n为主串的长度)：最好情况 O(m)，最坏O(m*n)"></node></node><node CREATED="1620645739937" ID="ID_c3be2ddaf510" MODIFIED="1620645739937" TEXT="KMP"><node CREATED="1620645739937" ID="ID_125c36d1bf41" MODIFIED="1620645739937" TEXT="当某次匹配失败时主串的开始比较位置不回退，而是利用部分字符匹配的结果将模式串向右移动较远的距离后再继续进行比较。"></node></node></node></node><node CREATED="1620645739937" ID="ID_804a78e0bae7" MODIFIED="1620645739937" TEXT="数组（具有n个相同数据类型的数据元素构成的集合）"><node CREATED="1620645739937" ID="ID_180c46dc815b" MODIFIED="1620645739937" TEXT="顺序存储的随机存储结构：按某种次序在地址连续的存储单元中"></node><node CREATED="1620645739937" ID="ID_6fa2b3646ce3" MODIFIED="1620645739937" TEXT="特点：&amp;nbsp;数组元素被存放在一组地址连续的存储单元里，并且每个元素的大小相同。"></node><node CREATED="1620645739937" ID="ID_17f0736a185a" MODIFIED="1620645739937" TEXT="遍历"><node CREATED="1620645739937" ID="ID_477c2c07e8bb" MODIFIED="1620645739937" TEXT="行主序"></node><node CREATED="1620645739937" ID="ID_bc5c5dcdc79d" MODIFIED="1620645739937" TEXT="列主序"></node></node><node CREATED="1620645739937" ID="ID_51df1afe7e01" MODIFIED="1620645739937" TEXT="特殊矩阵的压缩存储"><node CREATED="1620645739937" ID="ID_02e269e4b9bf" MODIFIED="1620645739937" TEXT="原则： 呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间"></node><node CREATED="1620645739937" ID="ID_24b012970c7b" MODIFIED="1620645739937" TEXT="三角矩阵的压缩存储"><node CREATED="1620645739937" ID="ID_e4a6882edb1c" MODIFIED="1620645739937" TEXT="线性压缩存储"></node><node CREATED="1620645739937" ID="ID_2baac2112ebc" MODIFIED="1620645739937" TEXT="三角形的二维数组压缩存储"></node></node><node CREATED="1620645739937" ID="ID_6724014aaf27" MODIFIED="1620645739937" TEXT="对称矩阵的压缩存储"></node><node CREATED="1620645739937" ID="ID_8f8affefafdb" MODIFIED="1620645739937" TEXT="对角矩阵的压缩存储"></node><node CREATED="1620645739937" ID="ID_79b869e0a74c" MODIFIED="1620645739937" TEXT="稀疏矩阵的压缩存储"><node CREATED="1620645739937" ID="ID_6009101471b5" MODIFIED="1620645739937" TEXT="非零元素三元组（行号、列号、元素）"></node><node CREATED="1620645739937" ID="ID_68349bec4586" MODIFIED="1620645739937" TEXT="十字链表存储"><node CREATED="1620645739937" ID="ID_29101d39f670" MODIFIED="1620645739937" TEXT="当稀疏矩阵中的非零元素的位置或个数经常发生变化时"></node><node CREATED="1620645739937" ID="ID_4588bfcd4b5e" MODIFIED="1620645739937" TEXT="五个域组成"><node CREATED="1620645739937" ID="ID_0da8122a0afc" MODIFIED="1620645739937" TEXT="row: 行号"></node><node CREATED="1620645739937" ID="ID_fe28e3af9017" MODIFIED="1620645739937" TEXT="column: 列号"></node><node CREATED="1620645739937" ID="ID_db9863152196" MODIFIED="1620645739937" TEXT="value:元素的值"></node><node CREATED="1620645739937" ID="ID_74d9e1946fe2" MODIFIED="1620645739937" TEXT="right: 与元素同行的下一个非零元素结点的指针"></node><node CREATED="1620645739937" ID="ID_d70736222f08" MODIFIED="1620645739937" TEXT="down：与元素同列的下一个非零元素结点的指针"></node></node></node><node CREATED="1620645739937" ID="ID_0063c52f7abc" MODIFIED="1620645739937" TEXT="原则：只给非零元素分配存储空间"></node></node></node><node CREATED="1620645739937" ID="ID_d744bbf6cff0" MODIFIED="1620645739937" TEXT="动态数组:&amp;nbsp; 在声明时没有确定数组大小的数组，即忽略圆括号中的下标；当要用它时，可随时用ReDim语句重新指出数组的大小。使用动态数组的优点是可以根据用户需要，有效利用存储空间。"></node></node></node><node CREATED="1620645739937" ID="ID_d59f472a9fc3" POSITION="right" MODIFIED="1620645739937" TEXT="树形结构"><node CREATED="1620645739937" ID="ID_12765db13bfa" MODIFIED="1620645739937" TEXT="特点:&amp;lt;br&amp;gt;1. 元素之间具有层次关系的非线性结构&amp;lt;br&amp;gt;2. 有且仅有一个被称为根的结点&amp;lt;br&amp;gt;3. 其余结点可分为m个互不相交的有限集合，每个集合又构成一棵树，叫根结点的子树。"></node><node CREATED="1620645739937" ID="ID_03e5ade71e9c" MODIFIED="1620645739937" TEXT="二叉树"><node CREATED="1620645739937" ID="ID_ccc7f563b7b7" MODIFIED="1620645739937" TEXT="存储结构"><node CREATED="1620645739937" ID="ID_3d867bbaa0c3" MODIFIED="1620645739937" TEXT="顺序存储：层次遍历。对于不完全的，会空置一些结点存储。"></node><node CREATED="1620645739937" ID="ID_dc3cf1fbb6ad" MODIFIED="1620645739937" TEXT="链式存储"><node CREATED="1620645739937" ID="ID_6ad26daa2776" MODIFIED="1620645739937" TEXT="二叉链式存储（空间利用率高）:设置两个指针域和一个数据域。&amp;lt;br&amp;gt;每个结点只存储了其孩子结点的单向关系，没有存储到父结点的关系。需要从根结点遍历查找。"></node><node CREATED="1620645739937" ID="ID_2aa802bf8e3a" MODIFIED="1620645739937" TEXT="三叉链式存储：设置三个指针域和一个数据域： parent、lchild、data、rchild&amp;lt;br&amp;gt;"></node></node></node><node CREATED="1620645739937" ID="ID_364e6a678e07" MODIFIED="1620645739937" TEXT="遍历方式"><node CREATED="1620645739937" ID="ID_8a19d2ccce6f" MODIFIED="1620645739937" TEXT="递归"><node CREATED="1620645739937" ID="ID_e2b8d6cef94f" MODIFIED="1620645739937" TEXT="先序遍历"></node><node CREATED="1620645739937" ID="ID_ae476cd71db5" MODIFIED="1620645739937" TEXT="中序遍历"></node><node CREATED="1620645739937" ID="ID_6f089fd1e15f" MODIFIED="1620645739937" TEXT="后序遍历"></node><node CREATED="1620645739937" ID="ID_74f3a92d6ff6" MODIFIED="1620645739937" TEXT="特点：结构简洁、易于实现、但开销大、运行效率低"></node><node CREATED="1620645739937" ID="ID_8c87b63cf679" MODIFIED="1620645739937" TEXT="&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;lt;br&amp;gt;"></node></node><node CREATED="1620645739937" ID="ID_2c2036a184cc" MODIFIED="1620645739937" TEXT="非递归"><node CREATED="1620645739937" ID="ID_54ae81c8a124" MODIFIED="1620645739937" TEXT="使用临时遍历保存中间结果，使用循环结构代替递归过程"></node><node CREATED="1620645739937" ID="ID_43d52e17f07a" MODIFIED="1620645739937" TEXT="利用栈保存中间结果：通过回溯访问二叉树的每个结点"><node CREATED="1620645739937" ID="ID_ce01a03da556" MODIFIED="1620645739937" TEXT="先序：&amp;lt;br&amp;gt;1. 将二叉树的根结点入栈&amp;lt;br&amp;gt;2. 若栈非空，将结点从栈中弹出并访问&amp;lt;br&amp;gt;3. 依次访问当前访问结点的左孩子结点，并将当前结点的右孩子结点入栈&amp;lt;br&amp;gt;4. 重复步骤2、3直到栈为空"></node><node CREATED="1620645739937" ID="ID_35f4d2d92a5f" MODIFIED="1620645739937" TEXT="中序：&amp;lt;br&amp;gt;1. 将二叉树根结点入栈&amp;lt;br&amp;gt;2. 若栈非空，将栈顶结点的左子结点入栈，直到栈顶结点的左子结点为空。&amp;lt;br&amp;gt;3. 将栈顶结点弹出并访问，并使栈顶结点的右子结点入栈&amp;lt;br&amp;gt;4. 重复2、3 直到栈为空"></node><node CREATED="1620645739937" ID="ID_88803cee04c5" MODIFIED="1620645739937" TEXT="后序：先访问左右子树，最后再访问自己。&amp;lt;br&amp;gt;"></node><node CREATED="1620645739937" ID="ID_a35ae37d9dc8" MODIFIED="1620645739937" TEXT="&amp;lt;b&amp;gt;层次:&amp;lt;br&amp;gt;1. 将根结点入队&amp;lt;br&amp;gt;2. 若队非空，取出队首结点并访问，将队首结点的孩子结点入队。&amp;lt;br&amp;gt;3. 重复执行步骤2直到队为空&amp;lt;/b&amp;gt;"></node></node></node></node><node CREATED="1620645739937" ID="ID_80d8c9eec2b3" MODIFIED="1620645739937" TEXT="遍历算法的应用"><node CREATED="1620645739937" ID="ID_a89fc531fe7e" MODIFIED="1620645739937" TEXT="查找算法：结点比左子结点数值大，比右子结点数值小"></node><node CREATED="1620645739937" ID="ID_4556cb0371c8" MODIFIED="1620645739937" TEXT="统计二叉树结点个数"></node><node CREATED="1620645739937" ID="ID_14ab34cd75c4" MODIFIED="1620645739937" TEXT="求二叉树深度"></node></node><node CREATED="1620645739937" ID="ID_5664a7cfebfe" MODIFIED="1620645739937" TEXT="二叉树的建立"><node CREATED="1620645739937" ID="ID_28646325ef1d" MODIFIED="1620645739937" TEXT="由中序和先序遍历序列建立二叉树（不大明白这段代码怎样就实现了创建二叉树）"><node CREATED="1620645739937" ID="ID_0827b9cb0b66" MODIFIED="1620645739937"></node></node><node CREATED="1620645739937" ID="ID_dc9f44b23cb4" MODIFIED="1620645739937" TEXT="标明空子树的先序遍历创建二叉树"></node></node><node CREATED="1620645739937" ID="ID_431654fabcc8" MODIFIED="1620645739937" TEXT="最优二叉树：哈夫曼树及哈夫曼编码（无损压缩技术）"><node CREATED="1620645739937" ID="ID_732bcbef94a2" MODIFIED="1620645739937" TEXT="特性：&amp;lt;br&amp;gt;1. 出现频率越高则权值给得越大，靠近根结点越近，减少判断量（比如学生成绩区域划分）&amp;lt;br&amp;gt;2. 前缀编码"></node><node CREATED="1620645739937" ID="ID_4f4c1e21beb9" MODIFIED="1620645739937" TEXT="哈夫曼编码：最早用于解决远距离电报通信的数据传输优化问题"></node><node CREATED="1620645739937" ID="ID_5340c2eea22f" MODIFIED="1620645739937" TEXT="给定n个带有权值的结点作为叶结点，构造出的具有最小带权路径长度的二叉树"></node></node><node CREATED="1620645739937" ID="ID_8dc552d7edfb" MODIFIED="1620645739937" TEXT="堆有时可以看作完全二叉树"><node CREATED="1620645739937" ID="ID_2c07f9342c72" MODIFIED="1620645739937" TEXT="①堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：&amp;lt;br&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;·堆中某个节点的值总是不大于或不小于其父节点的值；&amp;lt;br&amp;gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;·堆总是一棵完全二叉树。&amp;lt;br&amp;gt;将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。&amp;lt;br&amp;gt;②堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间。即动态分配内存，对其访问和对一般内存的访问没有区别。&amp;lt;br&amp;gt;③堆是应用程序在运行的时候请求操作系统分配给自己内存，一般是申请/给予的过程。&amp;lt;br&amp;gt;④堆是指程序运行时申请的动态内存，而栈只是指一种使用堆的方法(即先进后出)。"></node><node CREATED="1620645739937" ID="ID_d6e82213ab7f" MODIFIED="1620645739937" TEXT="动态分配的内存放在系统的堆里"></node><node CREATED="1620645739937" ID="ID_02ca25d919f5" MODIFIED="1620645739937"></node><node CREATED="1620645739937" ID="ID_a307db2c9cf0" MODIFIED="1620645739937" TEXT="heap这种树是按大小排的：从大到小叫max&amp;nbsp;heap，从小到大叫min&amp;nbsp;heap。堆都能用树来表示，并且一般树的实现都是利用链表。而二叉堆是一种特殊的堆，它用完全二叉树表示，却可以利用数组实现。"></node></node></node><node CREATED="1620645739937" ID="ID_9c7058ac11be" MODIFIED="1620645739937" TEXT="树和森林"><node CREATED="1620645739937" ID="ID_4fd1ef5a9366" MODIFIED="1620645739937" TEXT="树的层次关系必须用链式存储结构存储，通过链连接父节点和孩子结点"></node><node CREATED="1620645739937" ID="ID_1e09d4a2b239" MODIFIED="1620645739937" TEXT="一个结点的多个孩子结点（互称兄弟结点）之间是线性关系，可以采用顺序存储结构或链式存储结构"></node><node CREATED="1620645739937" ID="ID_4a73cb17a3d5" MODIFIED="1620645739937" TEXT="遍历：先序遍历和后序遍历"></node><node CREATED="1620645739937" ID="ID_0fbb3f49dca4" MODIFIED="1620645739937"></node></node><node CREATED="1620645739937" ID="ID_5873c0388fd2" MODIFIED="1620645739937" TEXT="红黑树"></node></node><node CREATED="1620645739937" ID="ID_3de94eb231c9" POSITION="right" MODIFIED="1620645739937" TEXT="图"><node CREATED="1620645739937" ID="ID_3a7b476e2ba8" MODIFIED="1620645739937" TEXT="特点:&amp;lt;br&amp;gt;元素间具有多对多关系的非线性数据结构。"></node><node CREATED="1620645739937" ID="ID_2ba5fe891e5f" MODIFIED="1620645739937" TEXT="存储结构"><node CREATED="1620645739937" ID="ID_4d858cd37215" MODIFIED="1620645739937" TEXT="邻接矩阵"><node CREATED="1620645739937" ID="ID_1872e811055c" MODIFIED="1620645739937" TEXT="采用数组存储，每插入或删除一个元素需要移动大量元素。数组容量有限，当扩充容量时，需要复制全部元素，效率更低。"></node></node><node CREATED="1620645739937" ID="ID_db842ed6d555" MODIFIED="1620645739937" TEXT="邻接表"><node CREATED="1620645739937" ID="ID_cdd0199c12a8" MODIFIED="1620645739937" TEXT="由一个顺序存储的顶点和多个链式存储的边组成"></node></node><node CREATED="1620645739937" ID="ID_96dab3a73ac2" MODIFIED="1620645739937" TEXT="十字链表"></node></node><node CREATED="1620645739937" ID="ID_09e14e8c958c" MODIFIED="1620645739937" TEXT="深度有限和广度优先"><node CREATED="1620645739937" ID="ID_35616bc51852" MODIFIED="1620645739937" TEXT="时间复杂度：&amp;lt;br&amp;gt;图有n个顶点和m条边,&amp;lt;br&amp;gt;当图的存储结构是邻接矩阵时，需要扫描邻接矩阵的每一个顶点，时间复杂度为 O(n^2)&amp;lt;br&amp;gt;当图的存储结构是邻接表时，需要扫描每一条单链表，时间复杂度为O(e)"></node></node><node CREATED="1620645739937" ID="ID_0cf9ea01242b" MODIFIED="1620645739937" TEXT="遍历"><node CREATED="1620645739937" ID="ID_4695ca26a28e" MODIFIED="1620645739937" TEXT="问题：&amp;lt;br&amp;gt;1. 指定遍历的第一个顶点&amp;lt;br&amp;gt;2. 由于一个顶点和多个顶点相邻，需要在多个邻接顶点间确定访问次序&amp;lt;br&amp;gt;3. 由于图中存在回路，必须对访问过的顶点做标记，防止出现重复访问同一顶点的情况"></node></node><node CREATED="1620645739937" ID="ID_191625d5d57b" MODIFIED="1620645739937" TEXT="最小生成树"><node CREATED="1620645739937" ID="ID_76ab77588561" MODIFIED="1620645739937" TEXT="&amp;lt;font color=&amp;quot;#c41230&amp;quot;&amp;gt;Kruskal&amp;lt;/font&amp;gt;"></node><node CREATED="1620645739937" ID="ID_2b2f9dd4c6e2" MODIFIED="1620645739937" TEXT="&amp;lt;font color=&amp;quot;#c41230&amp;quot;&amp;gt;Prim&amp;lt;/font&amp;gt;"></node><node CREATED="1620645739937" ID="ID_e12307c54b6d" MODIFIED="1620645739937" TEXT="一个有&amp;nbsp;n&amp;nbsp;个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有&amp;nbsp;n&amp;nbsp;个结点，并且有保持图连通的最少的边。 最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。"></node></node><node CREATED="1620645739937" ID="ID_0b6fca15db9d" MODIFIED="1620645739937" TEXT="最短路径"><node CREATED="1620645739937" ID="ID_9548907221e5" MODIFIED="1620645739937" TEXT="最短路径问题是图论研究中的一个经典算法问题，旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。&amp;nbsp;算法具体的形式包括：&amp;nbsp;确定起点的最短路径问题-&amp;nbsp;也叫单源最短路问题，即已知起始结点，求最短路径的问题。&amp;nbsp;在边权非负时适合使用Dijkstra算法，若边权为负时则适合使用Bellman-ford算法或者SPFA算法。"><node CREATED="1620645739937" ID="ID_4d0a858afe83" MODIFIED="1620645739937" TEXT="某个顶点到其余顶点的最短路径"></node><node CREATED="1620645739937" ID="ID_affeceb3622d" MODIFIED="1620645739937" TEXT="每一对顶点间的最短路径"></node></node><node CREATED="1620645739937" ID="ID_faaf6c37bda5" MODIFIED="1620645739937" TEXT="&amp;lt;font color=&amp;quot;#c41230&amp;quot;&amp;gt;Bellman-ford&amp;lt;/font&amp;gt;"></node><node CREATED="1620645739937" ID="ID_dd67f86adf7a" MODIFIED="1620645739937" TEXT="&amp;lt;font color=&amp;quot;#c41230&amp;quot;&amp;gt;SPFA&amp;lt;/font&amp;gt;"></node></node><node CREATED="1620645739937" ID="ID_67390dd14e91" MODIFIED="1620645739937" TEXT="拓扑排序和关键路径"><node CREATED="1620645739937" ID="ID_0a5a33d6695a" MODIFIED="1620645739937" TEXT="AOV网"></node><node CREATED="1620645739937" ID="ID_c20e979d1a45" MODIFIED="1620645739937" TEXT="AOE网"></node></node></node><node CREATED="1620645739937" ID="ID_6c6b113a34ac" POSITION="right" MODIFIED="1620645739937" TEXT="排序"><node CREATED="1620645739937" ID="ID_9a2bb3419444" MODIFIED="1620645739937" TEXT="插入排序（扑克牌整理）"></node><node CREATED="1620645739937" ID="ID_cce00ba508ba" MODIFIED="1620645739937" TEXT="希尔排序：每次将增量缩小一半，最后一个增量值必须为1"></node><node CREATED="1620645739937" ID="ID_1b39e2a11e2c" MODIFIED="1620645739937" TEXT="交换排序"><node CREATED="1620645739937" ID="ID_33fa3ac69e2b" MODIFIED="1620645739937" TEXT="冒泡排序（从左到右两两比较）"></node><node CREATED="1620645739937" ID="ID_6e226f00951c" MODIFIED="1620645739937" TEXT="快速排序（选择pivot，迭代）"></node></node><node CREATED="1620645739937" ID="ID_fd3bb0718342" MODIFIED="1620645739937" TEXT="选择排序（每次选择最大的元素放在最后）"></node><node CREATED="1620645739937" ID="ID_d93fd253d90f" MODIFIED="1620645739937" TEXT="堆排序"><node CREATED="1620645739937" ID="ID_805462badf04" MODIFIED="1620645739937"></node></node><node CREATED="1620645739937" ID="ID_56227459d414" MODIFIED="1620645739937" TEXT="归并排序"><node CREATED="1620645739937" ID="ID_4290ce40fb7b" MODIFIED="1620645739937" TEXT="L/R下标的移动"></node></node><node CREATED="1620645739937" ID="ID_11b6d8aaeb4e" MODIFIED="1620645739937" TEXT="算法的稳定性：要排序的内容是一个复杂对象的多个数字属性，且其原本的初始顺序存在意义，那么我们需要在二次排序的基础上保持原有排序的意义，才需要使用到稳定性的算法，例如要排序的内容是一组原本按照价格高低排序的对象，如今需要按照销量高低排序，使用稳定性算法，可以使得想同销量的对象依旧保持着价格高低的排序展现，只有销量不同的才会重新排序。（当然，如果需求不需要保持初始的排序意义，那么使用稳定性算法依旧将毫无意义）。"></node></node><node CREATED="1620645739937" ID="ID_4158153195da" POSITION="right" MODIFIED="1620645739937" TEXT="查找"><node CREATED="1620645739937" ID="ID_ae52be9f326d" MODIFIED="1620645739937" TEXT="查找表"><node CREATED="1620645739937" ID="ID_e20f797c811f" MODIFIED="1620645739937" TEXT="静态"><node CREATED="1620645739937" ID="ID_55444486ebd1" MODIFIED="1620645739937" TEXT="顺序查找"></node><node CREATED="1620645739937" ID="ID_1477ef716662" MODIFIED="1620645739937" TEXT="二分查找"></node><node CREATED="1620645739937" ID="ID_0091f84c2821" MODIFIED="1620645739937" TEXT="分块查找（索引查找）"><node CREATED="1620645739937" ID="ID_da1199d32e03" MODIFIED="1620645739937" TEXT="块间有序、块内无序"></node><node CREATED="1620645739937" ID="ID_dcc72cdc5e45" MODIFIED="1620645739937" TEXT="特点：&amp;lt;br&amp;gt;优点：插入和删除比较容易，无需进行大量移动&amp;lt;br&amp;gt;缺点： 要增加一个索引表的存储空间并堆初始索引表进行排序运算&amp;lt;br&amp;gt;适用情况：如果线性表既要快速查找又经常动态变化，则可用分块查找"></node></node></node><node CREATED="1620645739937" ID="ID_6d937ce89033" MODIFIED="1620645739937" TEXT="动态"><node CREATED="1620645739937" ID="ID_d92c23936e28" MODIFIED="1620645739937" TEXT="二叉排序树"><node CREATED="1620645739937" ID="ID_dd4dd48f1c6e" MODIFIED="1620645739937" TEXT="二叉排序树查找"><node CREATED="1620645739937" ID="ID_32155b058787" MODIFIED="1620645739937" TEXT="样例"></node></node><node CREATED="1620645739937" ID="ID_d016667d5f54" MODIFIED="1620645739937" TEXT="二叉排序树插入"></node><node CREATED="1620645739937" ID="ID_cea2ebca7f02" MODIFIED="1620645739937" TEXT="二叉排序树创建"></node><node CREATED="1620645739937" ID="ID_1b7f6c64ef27" MODIFIED="1620645739937" TEXT="二叉排序树删除"><node CREATED="1620645739937" ID="ID_0937ef432e05" MODIFIED="1620645739937" TEXT="左右子树非空， 有两种方法"></node><node CREATED="1620645739937" ID="ID_d69c25973033" MODIFIED="1620645739937" TEXT="方法二"></node><node CREATED="1620645739937" ID="ID_2f3e30ae1dd5" MODIFIED="1620645739937" TEXT="方法一"></node></node></node><node CREATED="1620645739937" ID="ID_25b268071411" MODIFIED="1620645739937" TEXT="平衡二叉树"><node CREATED="1620645739937" ID="ID_66bbfbeea632" MODIFIED="1620645739937" TEXT="平衡二叉树在插入节点和删除节点等动态操作上增加了自平衡的操作(通过旋转)"></node><node CREATED="1620645739937" ID="ID_05c88080b391" MODIFIED="1620645739937" TEXT="是二叉排序树的改进版本：左右子树深度之差的绝对值小于2，并左右子树均为平衡二叉树"></node><node CREATED="1620645739937" ID="ID_fffec639181e" MODIFIED="1620645739937" TEXT="1.二叉排序树的定义：&amp;lt;br&amp;gt;某结点左子树的所有结点的值都小于该节点的值且该结点右子树的值都大于该节点的值&amp;lt;br&amp;gt;2.平衡二叉树是特殊的二叉排序树&amp;lt;br&amp;gt;3.平衡因子：左子树高度－右子树高度&amp;lt;br&amp;gt;4.平衡二叉树必须满足以下两个条件：&amp;lt;br&amp;gt;1.必须是二叉排序树&amp;lt;br&amp;gt;2.平衡因子的绝对值小于等于1"></node></node><node CREATED="1620645739937" ID="ID_6078f99e5683" MODIFIED="1620645739937" TEXT="B-树、B+树"><node CREATED="1620645739937" ID="ID_0ff1ccb6c6b9" MODIFIED="1620645739937" TEXT="多路查找树，举例 2-3 树，2-3-4 树"><node CREATED="1620645739937" ID="ID_9614e7e773d8" MODIFIED="1620645739937"></node></node><node CREATED="1620645739937" ID="ID_49540942f1c3" MODIFIED="1620645739937" TEXT="性质： &amp;lt;br&amp;gt;&amp;lt;br&amp;gt;"></node><node CREATED="1620645739937" ID="ID_22415dcd7205" MODIFIED="1620645739937" TEXT="B树查找过程："></node><node CREATED="1620645739937" ID="ID_783616b4b7c9" MODIFIED="1620645739937" TEXT="B树插入（注意结点分裂和带来的连锁分裂的效果）"><node CREATED="1620645739937" ID="ID_fa5f4735e999" MODIFIED="1620645739937" TEXT="子主题"><node CREATED="1620645739937" ID="ID_a82ac8ab8f5e" MODIFIED="1620645739937" TEXT="子主题"></node></node></node><node CREATED="1620645739937" ID="ID_94e82f980f61" MODIFIED="1620645739937" TEXT="b树删除"><node CREATED="1620645739937" ID="ID_2a7ea3115156" MODIFIED="1620645739937" TEXT="子主题"><node CREATED="1620645739937" ID="ID_63c4ea530bb0" MODIFIED="1620645739937" TEXT="子主题"></node></node></node><node CREATED="1620645739937" ID="ID_f7467721a6ba" MODIFIED="1620645739937" TEXT="B+ 树"><node CREATED="1620645739937" ID="ID_0160af45d74b" MODIFIED="1620645739937" TEXT="高效的平衡查找树"><node CREATED="1620645739937" ID="ID_fdc92b12e4e0" MODIFIED="1620645739937" TEXT="特点：&amp;lt;br&amp;gt;1. 具有n个关键字的结点只含有n棵子树&amp;lt;br&amp;gt;2. 关键字n的范围是 m/2 &amp;lt;= n &amp;lt;= m, 对于b树则需要减去1&amp;lt;br&amp;gt;3. 叶结点包含信息，非叶结点仅起到索引作用，索引只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。再B树中每个关键字对应一个记录的存储地址。&amp;lt;br&amp;gt;4，有一个指针指向关键字最小的叶子节点，所有叶子结点链接成一个单链表。"></node></node><node CREATED="1620645739937" ID="ID_6cfff41a627e" MODIFIED="1620645739937" TEXT="为什么常用在数据库：&amp;lt;br&amp;gt;1. 二叉查找树比顺序查找要快&amp;lt;br&amp;gt;2. 平衡二叉树比普通二叉树要块&amp;lt;br&amp;gt;3. B树：单个结点可以存储多个键值和数据的平衡树&amp;lt;br&amp;gt;4. &amp;lt;br&amp;gt;4.1.&amp;nbsp;B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。&amp;nbsp;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;4.2.&amp;nbsp;因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。&amp;nbsp;&amp;nbsp;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是说上图中的B+树索引就是innodb中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。"><node CREATED="1620645739937" ID="ID_a0592fe4ba84" MODIFIED="1620645739937" TEXT="B树样例"><node CREATED="1620645739937" ID="ID_ec92830f1639" MODIFIED="1620645739937" TEXT="B+ 树样例"></node></node></node></node></node><node CREATED="1620645739937" ID="ID_bb0c6f6a9c0e" MODIFIED="1620645739937" TEXT="哈希表查找（空间换时间）"><node CREATED="1620645739937" ID="ID_305c7953b2ca" MODIFIED="1620645739937" TEXT="哈希函数"><node CREATED="1620645739937" ID="ID_260682c957b8" MODIFIED="1620645739937" TEXT="直接地址法"><node CREATED="1620645739937" ID="ID_270e71ade779" MODIFIED="1620645739937" TEXT="取关键字或者关键字的某个线性函数值作为哈希地址,即H(Key)=Key或者H(Key)=a*Key+b(a,b为整数),这种散列函数也叫做自身函数.如果H(Key)的哈希地址上已经有值了,那么就往下一个位置找,知道找到H(Key)的位置没有值了就把元素放进去."></node></node><node CREATED="1620645739937" ID="ID_153aa69bedbb" MODIFIED="1620645739937" TEXT="除留余数法"><node CREATED="1620645739937" ID="ID_34ce538d9f31" MODIFIED="1620645739937" TEXT="取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址.即H(Key)=Key&amp;nbsp;MOD&amp;nbsp;p,p&amp;lt;=m.不仅可以对关键字直接取模,也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选得不好，则很容易产生冲突。一般p取值为表的长度tableSize。"></node></node><node CREATED="1620645739937" ID="ID_5afc644116f4" MODIFIED="1620645739937" TEXT="数字分析法"><node CREATED="1620645739937" ID="ID_c3ad0f3aba3a" MODIFIED="1620645739937" TEXT="分析一组数据,比如一组员工的出生年月,这时我们发现出生年月的前几位数字一般都相同,因此,出现冲突的概率就会很大,但是我们发现年月日的后几位表示月份和具体日期的数字差别很大,如果利用后面的几位数字来构造散列地址,则冲突的几率则会明显降低.因此数字分析法就是找出数字的规律,尽可能利用这些数据来构造冲突几率较低的散列地址.&amp;lt;br&amp;gt;"></node></node><node CREATED="1620645739937" ID="ID_3f7b60214b17" MODIFIED="1620645739937" TEXT="平方取中法"><node CREATED="1620645739937" ID="ID_a44713131352" MODIFIED="1620645739937" TEXT="取关键字平方后的中间几位作为散列地址.一个数的平方值的中间几位和数的每一位都有关。因此，有平方取中法得到的哈希地址同关键字的每一位都有关，是的哈希地址具有较好的分散性。该方法适用于关键字中的每一位取值都不够分散或者较分散的位数小于哈希地址所需要的位数的情况。"></node></node><node CREATED="1620645739937" ID="ID_fb360bdc8963" MODIFIED="1620645739937" TEXT="折叠法"><node CREATED="1620645739937" ID="ID_e8616e6c7d02" MODIFIED="1620645739937" TEXT="折叠法即将关键字分割成位数相同的几部分,最后一部分位数可以不同,然后取这几部分的叠加和(注意:叠加和时去除进位)作为散列地址.数位叠加可以有移位叠加和间界叠加两种方法.移位叠加是将分割后的每一部分的最低位对齐,然后相加;间界叠加是从一端向另一端沿分割界来回折叠,然后对齐相加."></node></node><node CREATED="1620645739937" ID="ID_3b8080955fef" MODIFIED="1620645739937" TEXT="随机数法"><node CREATED="1620645739937" ID="ID_1eb8dc424026" MODIFIED="1620645739937" TEXT="选择一个随机数,去关键字的随机值作为散列地址,通常用于关键字长度不同的场合."></node></node></node><node CREATED="1620645739937" ID="ID_8216e6f38875" MODIFIED="1620645739937" TEXT="解决冲突"><node CREATED="1620645739937" ID="ID_c8b493e06ecb" MODIFIED="1620645739937" TEXT="开放定址法：线性探测法：每一个地址，都对所有元素是开放的。遇到哈希冲突，就取下一个空地址；平方探测法 +1、+4、+9、+16 ...."></node><node CREATED="1620645739937" ID="ID_125f4f8ebef4" MODIFIED="1620645739937" TEXT="链地址法（封闭地址）"><node CREATED="1620645739937" ID="ID_459e2e55dbb4" MODIFIED="1620645739937" TEXT="将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。"></node></node><node CREATED="1620645739937" ID="ID_0e12fc66ed0b" MODIFIED="1620645739937" TEXT="公共溢出区法"><node CREATED="1620645739937" ID="ID_3dd0bf92bacf" MODIFIED="1620645739937" TEXT="将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。"></node></node><node CREATED="1620645739937" ID="ID_98c9ec547def" MODIFIED="1620645739937" TEXT="再哈希法"></node></node><node CREATED="1620645739937" ID="ID_ad1140bb5522" MODIFIED="1620645739937" TEXT="哈希表(Hash&amp;nbsp;Table)也叫散列表，是根据关键码值（Key&amp;nbsp;Value）而直接进行访问的数据结构。它通过把关键码值映射到哈希表中的一个位置来访问记录，以加快查找的速度。这个映射函数就做散列函数，存放记录的数组叫做散列表。"></node></node></node></node><node CREATED="1620645739937" ID="ID_ba85076c56e5" MODIFIED="1620645739937" TEXT="平均查找长度ASL"><node CREATED="1620645739937" ID="ID_94d35aee1e0d" MODIFIED="1620645739937" TEXT="给定值与关键字值的比较次数的期望值"></node></node></node></node></map>